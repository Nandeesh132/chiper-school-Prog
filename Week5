Date:24/March/2025  (Monday)

206. Reverse Linked List
Solved
Easy
Topics
Companies
Given the head of a singly linked list, reverse the list, and return the reversed list.

 

Example 1:


Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
Example 2:


Input: head = [1,2]
Output: [2,1]
Example 3:

Input: head = []
Output: []
 

Constraints:

The number of nodes in the list is the range [0, 5000].
-5000 <= Node.val <= 5000
 
code 1:
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) return head;

        ListNode prev = null;
        ListNode curr = head;
        ListNode next = null;
        
        while (curr!= null ){
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
            
        }
        return prev ;      
    }
}
code 2:

import java.util.ArrayList;

class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;

        ArrayList<ListNode> nodeList = new ArrayList<>();

        // Step 1: Store all nodes in the ArrayList
        ListNode temp = head;
        while (temp != null) {
            nodeList.add(temp);
            temp = temp.next;
        }

        // Step 2: Reverse the links using the ArrayList
        for (int i = nodeList.size() - 1; i > 0; i--) {
            nodeList.get(i).next = nodeList.get(i - 1);
        }

        // Step 3: Set the next of the first node to null (new tail)
        nodeList.get(0).next = null;

        // Return the new head (last element in ArrayList)
        return nodeList.get(nodeList.size() - 1);
    }
}
code 3:
class Solution {
    public ListNode reverseList(ListNode head) {
        // Base case: If the list is empty or has only one node, return it as is
        if (head == null || head.next == null) {
            return head;
        }

        // Initialize three pointers:
        ListNode prev = null;    // Previous node (initially null)
        ListNode curr = head;    // Current node (starting from head)
        ListNode next = head.next; // Next node (storing head.next initially)
        
        // Iterate through the list until next becomes null
        while (next != null) {
            curr.next = prev;  // Reverse the current node's pointer
            prev = curr;       // Move prev forward
            curr = next;       // Move curr forward
            next = next.next;  // Move next forward
        }

        // After the loop, curr is at the last node, so reverse its pointer
        curr.next = prev;

        // Return the new head (which is the last node in the original list)
        return curr;
    }
}


234. Palindrome Linked List
Solved
Easy
Topics
Companies
Given the head of a singly linked list, return true if it is a palindrome or false otherwise.

 

Example 1:


Input: head = [1,2,2,1]
Output: true
Example 2:


Input: head = [1,2]
Output: false
 

code1 : using arraylist and check palindrome

import java.util.ArrayList;

class Solution {
    public boolean isPalindrome(ListNode head) {
        // Step 1: Store all values from the linked list into an ArrayList
        ArrayList<Integer> list = new ArrayList<>();
        ListNode temp = head;
        
        // Traverse the linked list and add values to the ArrayList
        while (temp != null) { 
            list.add(temp.val);
            temp = temp.next;
        }

        // Step 2: Use two-pointer technique to check if the list is a palindrome
        int low = 0;               // Start pointer (beginning of the list)
        int end = list.size() - 1; // End pointer (end of the list)

        while (low < end) { 
            // Compare elements from start and end
            if (!list.get(low).equals(list.get(end))) { // Fix: Use .equals() for Integer comparison
                return false; // If any mismatch is found, it's not a palindrome
            }
            low++;  // Move start pointer forward
            end--;  // Move end pointer backward
        }

        return true; // If all elements matched, the list is a palindrome
    }
}



code 2: using mid reverse and check
class Solution {
    public ListNode reverse(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        ListNode next = null; // Fix: next should be null initially to avoid NullPointerException

        while (curr != null) { // Fix: Loop should run while curr is not null
            next = curr.next;  // Store the next node
            curr.next = prev;  // Reverse the current node's pointer
            prev = curr;       // Move prev to curr
            curr = next;       // Move curr to next node
        }
        return prev; // prev is now the head of the reversed list
    }

    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) return true; // Fix: Single node is a palindrome
        // ListNode temp = head;
        // int count =1;
        // while(temp.next != null){
        //     count++;
        //     temp = temp.next;
        // }
        // int mid = count/2;
        ListNode slow = head, fast = head;

        // Step 1: Find the middle of the linked list
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Step 2: Reverse the second half of the list
        slow = reverse(slow);

        // Step 3: Compare first half with the reversed second half
        ListNode temp = head;
        // ListNode secondHalf = slow;

        while (slow != null ) { // Fix: Compare until secondHalf is null
            if (temp.val != slow.val) {
                return false;
            }
            temp = temp.next;
            slow = slow.next;
        }


        return true;
    }
}

///////////////////////////////////////////////
Date: 25/03/2024

// reverse a double linked list,
 //leetcode 2816
 //copy list with random pointer
 //add 1 to a linked list

//stack
//Stack using Arraylist
import java.util.*;

class Main {
    class Stack {
        ArrayList<Integer> list;

        Stack() { // Constructor
            list = new ArrayList<>();
        }

        public void add(int element) {
            list.add(element);
        }

        public int peek() { // Fixed method name
            if (list.isEmpty()) return -1;
            return list.get(list.size() - 1);
        }

        public int pop() {
            if (list.isEmpty()) return -1;
            int element = this.peek();
            list.remove(list.size() - 1);
            return element;
        }

        public int getSize() { // Fixed missing return
            return list.size();
        }
    }

    public static void main(String[] args) {
        Main mainInstance = new Main(); // Create an instance of Main
        Stack s = mainInstance.new Stack(); // Instantiate inner class

        s.add(1);
        s.add(12);
        s.add(21);
        s.add(22);
        s.add(23);

        System.out.println(s.peek()); // Output: 23
        System.out.println(s.pop());  // Output: 23
        System.out.println(s.getSize()); // Output: 4
    }
}


//Stack using Linkedlist (Hint: add at the front not backside)?
////Stack using Sinngle Linkedlist
import java.util.*;

class Main {
    class Stack {
        LinkedList<Integer> list;

        Stack() { // Constructor
            list = new LinkedList<>();
        }

        public void add(int element) {
            list.addFirst(element);
        }

        public int peek() { // Fixed method name
            if (list.isEmpty()) return -1;
            return list.peekFirst();
        }

        public int pop() {
            if (list.isEmpty()) return -1;
            int element = this.peek();
            list.remove();
            return element;
        }

        public int getSize() { // Fixed missing return
            return list.size();
        }
    }

    public static void main(String[] args) {
        Main mainInstance = new Main(); // Create an instance of Main
        Stack s = mainInstance.new Stack(); // Instantiate inner class

        s.add(1);
        s.add(12);
        s.add(21);
        s.add(22);
        s.add(23);

        System.out.println(s.peek()); // Output: 23
        System.out.println(s.pop());  // Output: 23
        System.out.println(s.getSize()); // Output: 4
        System.out.println(s.peek());
    }
}


2816. Double a Number Represented as a Linked List
Solved
Medium
Topics
Companies
Hint
You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.

Return the head of the linked list after doubling it.

 

Example 1:


Input: head = [1,8,9]
Output: [3,7,8]
Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode doubleIt(ListNode head) {
        // Reverse the linked list to process from least significant digit
        head = reverse(head);
        
        ListNode temp = head;
        ListNode prev = null;
        int carry = 0;
        
        while (temp != null) {
            int newVal = temp.val * 2 + carry;
            temp.val = newVal % 10;
            carry = newVal / 10;
            
            prev = temp;
            temp = temp.next;
        }
        
        // If there is a carry left, add a new node
        if (carry > 0) {
            prev.next = new ListNode(carry);
        }
        
        // Reverse the list back to original order
        return reverse(head);
    }
    
    private ListNode reverse(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode nextNode = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextNode;
        }
        return prev;
    }
}
////////////////////////////////////////////////////////////
Date: 26/03/2025

LC 402. Remove K Digits
LC 503. 
LC 907.

Leetcode 402
402. Remove K Digits
Solved
Medium
Topics
Companies
Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.

 

Example 1:

Input: num = "1432219", k = 3
Output: "1219"
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
Example 2:

Input: num = "10200", k = 1
Output: "200"
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.
class Solution {
    public String removeKdigits(String num, int k) {
        if(k== num.length()){
            return "0";
        }
        Stack <Character> s= new Stack<>();
        for(int i=0; i<num.length();i++){
            char c= num.charAt(i);
            while(!s.isEmpty() && k>0 && s.peek()>c){
                s.pop();
                k--;

            }
            s.push(c);
        }
        while(! s.isEmpty() && k>0){// for k>0 and stack is sorted. 
            s.pop();
            k--;
        }
        StringBuilder result = new StringBuilder();
        while(!s.isEmpty()){
            result.append(s.pop());
        }//if we use this we want to use reverse because the string save the elements from top using pop so .
        // //
        // for(char ch :s){
        //     sb.append(ch);
        // } when for loop is used stack is take element from down. so reverse is not requiored.
        result.reverse();
        while(result.length()>0 && result.charAt(0)=='0'){//edge case if 000123 then remove 123.
            result.deleteCharAt(0);
        }
        return result.length() == 0 ? "0": result.toString();


    }
}
