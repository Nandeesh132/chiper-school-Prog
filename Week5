Date:24/March/2025  (Monday)

206. Reverse Linked List
Solved
Easy
Topics
Companies
Given the head of a singly linked list, reverse the list, and return the reversed list.

 

Example 1:


Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
Example 2:


Input: head = [1,2]
Output: [2,1]
Example 3:

Input: head = []
Output: []
 

Constraints:

The number of nodes in the list is the range [0, 5000].
-5000 <= Node.val <= 5000
 
code 1:
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) return head;

        ListNode prev = null;
        ListNode curr = head;
        ListNode next = null;
        
        while (curr!= null ){
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
            
        }
        return prev ;      
    }
}
code 2:

import java.util.ArrayList;

class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;

        ArrayList<ListNode> nodeList = new ArrayList<>();

        // Step 1: Store all nodes in the ArrayList
        ListNode temp = head;
        while (temp != null) {
            nodeList.add(temp);
            temp = temp.next;
        }

        // Step 2: Reverse the links using the ArrayList
        for (int i = nodeList.size() - 1; i > 0; i--) {
            nodeList.get(i).next = nodeList.get(i - 1);
        }

        // Step 3: Set the next of the first node to null (new tail)
        nodeList.get(0).next = null;

        // Return the new head (last element in ArrayList)
        return nodeList.get(nodeList.size() - 1);
    }
}
code 3:
class Solution {
    public ListNode reverseList(ListNode head) {
        // Base case: If the list is empty or has only one node, return it as is
        if (head == null || head.next == null) {
            return head;
        }

        // Initialize three pointers:
        ListNode prev = null;    // Previous node (initially null)
        ListNode curr = head;    // Current node (starting from head)
        ListNode next = head.next; // Next node (storing head.next initially)
        
        // Iterate through the list until next becomes null
        while (next != null) {
            curr.next = prev;  // Reverse the current node's pointer
            prev = curr;       // Move prev forward
            curr = next;       // Move curr forward
            next = next.next;  // Move next forward
        }

        // After the loop, curr is at the last node, so reverse its pointer
        curr.next = prev;

        // Return the new head (which is the last node in the original list)
        return curr;
    }
}


234. Palindrome Linked List
Solved
Easy
Topics
Companies
Given the head of a singly linked list, return true if it is a palindrome or false otherwise.

 

Example 1:


Input: head = [1,2,2,1]
Output: true
Example 2:


Input: head = [1,2]
Output: false
 

code1 : using arraylist and check palindrome

import java.util.ArrayList;

class Solution {
    public boolean isPalindrome(ListNode head) {
        // Step 1: Store all values from the linked list into an ArrayList
        ArrayList<Integer> list = new ArrayList<>();
        ListNode temp = head;
        
        // Traverse the linked list and add values to the ArrayList
        while (temp != null) { 
            list.add(temp.val);
            temp = temp.next;
        }

        // Step 2: Use two-pointer technique to check if the list is a palindrome
        int low = 0;               // Start pointer (beginning of the list)
        int end = list.size() - 1; // End pointer (end of the list)

        while (low < end) { 
            // Compare elements from start and end
            if (!list.get(low).equals(list.get(end))) { // Fix: Use .equals() for Integer comparison
                return false; // If any mismatch is found, it's not a palindrome
            }
            low++;  // Move start pointer forward
            end--;  // Move end pointer backward
        }

        return true; // If all elements matched, the list is a palindrome
    }
}



code 2: using mid reverse and check
class Solution {
    public ListNode reverse(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        ListNode next = null; // Fix: next should be null initially to avoid NullPointerException

        while (curr != null) { // Fix: Loop should run while curr is not null
            next = curr.next;  // Store the next node
            curr.next = prev;  // Reverse the current node's pointer
            prev = curr;       // Move prev to curr
            curr = next;       // Move curr to next node
        }
        return prev; // prev is now the head of the reversed list
    }

    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) return true; // Fix: Single node is a palindrome
        // ListNode temp = head;
        // int count =1;
        // while(temp.next != null){
        //     count++;
        //     temp = temp.next;
        // }
        // int mid = count/2;
        ListNode slow = head, fast = head;

        // Step 1: Find the middle of the linked list
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Step 2: Reverse the second half of the list
        slow = reverse(slow);

        // Step 3: Compare first half with the reversed second half
        ListNode temp = head;
        // ListNode secondHalf = slow;

        while (slow != null ) { // Fix: Compare until secondHalf is null
            if (temp.val != slow.val) {
                return false;
            }
            temp = temp.next;
            slow = slow.next;
        }


        return true;
    }
}

///////////////////////////////////////////////
Date: 25/03/2024

// reverse a double linked list,
 //leetcode 2816
 //copy list with random pointer
 //add 1 to a linked list

//stack
//Stack using Arraylist
class Main {
    class Stack{
            ArrayList<Integer> list;
            
            Stack(){//constructor
                list = new ArrayList<>();
            }
            public void add(){
                list.add(element);
            }
            
            public int peak(){
                if(list.size() == 0) return -1;
                return list.get(list.size()-1);
            }
            
            public int pop(){
                if(list.size() == 0)return -1;
int element = this.peek();
list.remove(list.size()-1);
return element;
                return list.remove(list.size()-1);
            }
            public int getSize(){
                 list.size(); 
            }
        }
    public static void main(String[] args) {
        
    }
}

//Stack using Linkedlist (Hint: add at the front not backside)?
