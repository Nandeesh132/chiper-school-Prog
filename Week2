Date: 3/3/2025..   Monday.
LeetCode 287. Find the Duplicate Number
Attempted

Medium

Topics

Companies
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and using only constant extra space.
 
Example 1:
Input: nums = [1,3,4,2,2]
Output: 2
Example 2:
Input: nums = [3,1,3,4,2]
Output: 3
Example 3:
Input: nums = [3,3,3,3,3]
Output: 3
 
Code 1 : brute force not work in leetcode because time limit exceeded
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length;
        for(int i =0;i< n-1;i++){
            for(int j=i+1;j<n;j++){
                if(nums[i]== nums[j]){
                    return nums[i];
                }
            }
        }
        return 0;
    }
}
Code 2: Using HashSet
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length;
       HashSet<Integer> hs=new HashSet <>();
       for(int i =0;i<n;i++){
        int num = nums[i];
        if(!hs.contains(num)){
            hs.add(num);
        }
        else if(hs.contains(num)){
            return num;
        }
       }
        return 0;
    }
}
Code 3: Using HashMap
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length;
       HashMap<Integer,Integer> hs=new HashMap <>();
       for(int i =0;i<n;i++){
        int num = nums[i];
        if(!hs.containsKey(num)){
            hs.put(num,1);
        }
        else if(hs.containsKey(num)){
            return num;
        }
       }
        return 0;
    }
}

Code 4: Brute force Running in Leetcode

242. Valid Anagram
Solved

Easy

Topics

Companies
Given two strings s and t, return true if t is an anagram of s, and false otherwise.
 
Example 1:
Input: s = "anagram", t = "nagaram"
Output: true
Example 2:
Input: s = "rat", t = "car"
Output: false
Code 2: using two frequency arrays
class Solution {
    public boolean isAnagram(String s, String t) {
        boolean ans = true;
        int[] sfreq = new int[26];
        int[] rfreq = new int[26];
        for(int i=0;i<s.length();i++){
            char sc = s.charAt(i);
            int sindex = sc-'a';
            sfreq[sindex]++;
        }
        for(int i =0;i<t.length();i++){
            char rc = t.charAt(i);
            int rindex = rc-'a';
            rfreq[rindex]++;
        }
        for(int i=0;i<sfreq.length;i++){
            if(sfreq[i]!=rfreq[i]){
                ans = false;
            }
        }
        return ans;
    }
}

String Duplicates Removal

https://www.geeksforgeeks.org/problems/remove-all-duplicates-from-a-given-string4321/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card

Difficulty: EasyAccuracy: 58.68%Submissions: 105K+Points: 2Average Time: 15m

Given a string s which may contain lowercase and uppercase characters. The task is to remove all duplicate characters from the string and find the resultant string. The order of remaining characters in the output should be same as in the original string.
Example 1:
Input: s = "geEksforGEeks" Output: "geEksforG" Explanation: After removing duplicate characters such as E, e, k, s, we have string as "geEksforG".
Code 1: using hashes and StringBuilder
class Solution {
    String removeDuplicates(String s) {
        HashSet <Character> hs = new HashSet<>();
        StringBuilder ans = new StringBuilder(); 
        for(int i=0; i<s.length();i++){
            char c = s.charAt(i);
            if(!hs.contains(c)){
                hs.add(c);
                ans.append(c);
            }
            
        }
        String result= ans.toString();
        return result;   
    }
}
Code 2: using frequency array method

class Solution {
    String removeDups(String s) {
        // code here
        int[] freq =new int[256];
        StringBuilder ans = new StringBuilder(); 
        for(int i=0; i<s.length();i++){
            char c = s.charAt(i);
            int index = (int) c;
            freq[index]++;
            if(freq[index]==1){
                ans.append(c);
            }
            
        }
        // String result= ans.toString();
        // return result;
        return ans.toString();
    }
}
// code to remove non alphanumeric vaules from string and converting the string to all lower case.
class Main {
    public static void main(String[] args) {
        String s = "AB!Cba";
        s = s.replaceAll(
          "[^a-zA-z]", "");
        s=s.toLowerCase();
        
        for(int i=0;i<s.length();i++){
            System.out.println(s.charAt(i));
        }
    }
}
LeetCode 125. Valid Palindrome
Easy

Topics

Companies
A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
Given a string s, return true if it is a palindrome, or false otherwise.
 
Example 1:
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
Code 1:
class Solution {
    public boolean isPalindrome(String s) {
        boolean ans = true;
        s=s.toLowerCase();
        s = s.replaceAll(
          "[^a-z0-9]”, "");
          int n = s.length();
          int i=0;
          int j=n-1;
          while(i<j){
            if(s.charAt(i)!= s.charAt(j)){
                ans =false;
            }
            i++;
            j--;
          }
        return ans;
    }
}
LeetCode 387. First Unique Character in a String
Solved

Easy

Topics

Companies
Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.
 
Example 1:
Input: s = "leetcode"
Output: 0
Explanation:
The character 'l' at index 0 is the first character that does not occur at any other index.
Example 2:
Input: s = "loveleetcode"
Output: 2

Code1: Using HashMap
class Solution {
    public int firstUniqChar(String s) {
        HashMap <Character,Integer> hs =new HashMap<>();
        for(int i =0; i<s.length();i++){
            char a =s.charAt(i);
            hs.put(a,hs.getOrDefault(a,0)+1);
        }
        for(int i =0;i<s.length();i++){
            if(hs.get(s.charAt(i))==1){
                return i;
            }
        }
        return -1;
    }
}

LeetCode 3. Longest Substring Without Repeating Characters
Solved

Medium

Topics

Companies

Hint
Given a string s, find the length of the longest substring without duplicate characters.
 
Example 1:
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Example 2:
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        int maxLength = 0;
        int l = 0;
        int r = 0;
        HashSet<Character> hs = new HashSet<>();

        while (r < s.length()) {
            if (!hs.contains(s.charAt(r))) {
                hs.add(s.charAt(r));
                maxLength = Math.max(maxLength, r - l + 1);
                r++;
            } else {
                hs.remove(s.charAt(l));
                l++;
            }
        }

        return maxLength;
    }
}
/////////////////////////////////////////////////////////
Date: 4/03/2025
Leetcode 38
38. Count and Say
Solved

Medium

Topics

Companies

Hint
The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
* countAndSay(1) = "1"
* countAndSay(n) is the run-length encoding of countAndSay(n - 1).
Run-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "3322251" we replace "33" with "23", replace "222" with "32", replace "5" with "15" and replace "1" with "11". Thus the compressed string becomes "23321511".
Given a positive integer n, return the nth element of the count-and-say sequence.
 
Example 1:
Input: n = 4
Output: "1211"
Explanation:
countAndSay(1) = "1"
countAndSay(2) = RLE of "1" = "11"
countAndSay(3) = RLE of "11" = "21"
countAndSay(4) = RLE of "21" = "1211"
Code 1: 
class Solution {
    public String countAndSay(int n) {
        if(n==1) return "1";
        String lastnum = countAndSay(n-1);
        int index =0;
        StringBuilder sb = new StringBuilder();
        while(index < lastnum.length()){
            char currEle=lastnum.charAt(index);//here current element is saved the character of string 
            index++;

            int freq =1;
            while(index<lastnum.length()){
                if(lastnum.charAt(index) != currEle)break;
                    index++;
                    freq++;
                }
                sb.append(Integer.toString(freq));
                sb.append(currEle);
            
        }

        return sb.toString();
    }
}
1780. Check if Number is a Sum of Powers of Three
Solved

Medium

Topics

Companies

Hint
Given an integer n, return true if it is possible to represent n as the sum of distinct powers of three. Otherwise, return false.
An integer y is a power of three if there exists an integer x such that y == 3x.
 
Example 1:
Input: n = 12
Output: true
Explanation: 12 = 31 + 32
Example 2:
Input: n = 91
Output: true
Explanation: 91 = 30 + 32 + 34

class Solution {
    public boolean checkPowersOfThree(int n) {
         while(n>0){
            if(n%3!=0) {
                n = n - 1;
            }

            if(n%3 != 0) return false;

            n/=3;
        }
        return true;
    }
}

//////////////////////////////////////////////////////////////////////////////////////
Date: 5/03/2025
Leetcode 231
Leetcode 326
Leetcode 342
231. Power of Two
Solved

Easy

Topics

Companies
Given an integer n, return true if it is a power of two. Otherwise, return false.
An integer n is a power of two, if there exists an integer x such that n == 2x.
 
Example 1:
Input: n = 1
Output: true
Explanation: 20 = 1
Example 2:
Input: n = 16
Output: true
Explanation: 24 = 16

class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n<=0){
            return false;
        }
        while(n>0){
            if(n==1){
                return true;
            }
            if(n%2!=0){ 
                return false;
            }
            n=n/2;  
        }
        return true;
    }
}
326. Power of Three
Solved

Easy

Topics

Companies
Given an integer n, return true if it is a power of three. Otherwise, return false.
An integer n is a power of three, if there exists an integer x such that n == 3x.
 
Example 1:
Input: n = 27
Output: true
Explanation: 27 = 33
Example 2:
Input: n = 0
Output: false
Explanation: There is no x where 3x = 0.


class Solution {
    public boolean isPowerOfThree(int n) {
        if(n<=0){
            return false;
        }
        while(n>0){
            if(n==1){
                return true;
            }
            if(n%3 !=0){
                return false;
            }
            n=n/3;
        }
        return true;
    }
}

342. Power of Four
Solved

Easy

Topics

Companies
Given an integer n, return true if it is a power of four. Otherwise, return false.
An integer n is a power of four, if there exists an integer x such that n == 4x.
 
Example 1:
Input: n = 16
Output: true
Example 2:
Input: n = 5
Output: false
Example 3:
Input: n = 1
Output: true

class Solution {
    public boolean isPowerOfFour(int n) {
        if(n<=0){
            return false;
        }
        while(n>0){
            if(n==1){
                return true;
            }
            if(n%4!=0){
                return false;
            }
            n=n/4;
            
        }
        return true;
    }
}

Rabbin Harp
In pattern matching
Description

2579. Count Total Number of Colored Cells
Solved

Medium

Topics

Companies

Hint
There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer n, indicating that you must do the following routine for n minutes:
* At the first minute, color any arbitrary unit cell blue.
* Every minute thereafter, color blue every uncolored cell that touches a blue cell.
Below is a pictorial representation of the state of the grid after minutes 1, 2, and 3.
￼
Return the number of colored cells at the end of n minutes.
 
Example 1:
Input: n = 1
Output: 1
Explanation: After 1 minute, there is only 1 blue cell, so we return 1.

class Solution {
    public long coloredCells(int n) {
        long sum=1; // Initial number of colored cells
        for(int i=2; i<=n; i++){
            sum+=(i-1)*4; // Increment by 4 times the previous level
        }
        return sum;
    }
}
///////////////////////////////////////////////
Date: 6/05/2025

// Linear Searching
class Main {
    public static void main(String[] args) {
        int[] arr={1,2,3,4,5,6,7,8};
        int target =7;// Find the target in the array where it is located
        for(int i=0; i<arr.length;i++){
            if(arr[i]== target){
                System.out.print(i);
            }
        }
        
    }
}

// Binary Searching
// in binary searching first we want to sort the array it is compulsory
// here we take two pointers and one while loop.
import java.util.Arrays;
class Main {
    public static void main(String[] args) {
        int[] arr={1,2,3,4,5,8,9,6,10,11};
        Arrays.sort(arr);// used to sort the array
        int n = arr.length;
        System.out.println(n);
        int low =0;//storinh low index.
        int high = n-1;// storing high index.
        
        int target =6;// Find the target in the array where it is located
        while(low <= high){//here three index 
            int mid = (low+high)/2;// finding the mid of that array
            if(arr[mid]==target){// if same directly print the mid 
                System.out.print(mid);
                break;
            }
            else if(arr[mid]>target){// mid value higher than the target then update the high value as mid-1 index
                high= mid-1;
                
            }
            else{
                low = mid+1;//if mid value is less than target then update the low as mid+1 index
            }
            
        }
    }
}

// Bubble Sort Algorithm

class Main {
    public static void main(String[] args) {
        int[] arr ={10,1,2,4,3,5,6,7,8,9};
        //int[] arr={9,0,6,8,3};
        System.out.println(arr.length);
        for(int i =0;i<arr.length-1;i++){
            boolean swapped = false;
            for(int j=i+1;j<arr.length;j++){
                if(arr[i]>arr[j]){
                    int temp=arr[i];
                    arr[i]=arr[j];
                    arr[j]=temp;
                    swapped = true;
                }
            }
            if(swapped == false){// if arr[i] is not greater than arr[j] in all itreation then it break the i loop.
                break;
            }
            
        }
        for(int i =0;i<arr.length;i++){
            System.out.print(arr[i]+" ");
        }
    }
}
output 
10
1 2 3 4 5 6 7 8 9 10 

// Selection Sort Algo
class Main {
    public static void main(String[] args) {
        int[] arr = {10,5,6,7,2,4,3,1};
        int n=arr.length;
        for(int i =0;i<n-1;i++){
            int min = i;// index of the ele
            for(int j=i+1;j<n;j++){
                if(arr[min]>arr[j]){// value of min index is graeter than remaining values then swap
                    int temp=arr[min];
                    arr[min]=arr[j];
                    arr[j] = temp;
                    System.out.println("fixed min = "+min);
                }
            }
        }
        for(int i=0;i<n;i++ ){
            System.out.println(arr[i]);
        }
    }
} 
// insertion sort
class Main {
    public static void main(String[] args) {
        int[] arr = {10, 2, 3, 5, 4, 1}; // Unsorted array
        int n = arr.length;
        
        for (int i = 1; i < n; i++) { // Start from the second element
            int key = arr[i]; // Current element to insert
            int j = i - 1;
            
            // Shift elements to the right to create the correct position for key
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key; // Insert key in the correct position
        }

        // Print the sorted array
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
output 1 2 3 4 5 10 .
//Q. take input of two num arr and output as merge of both arrays  in sorted 
class Main {
    public static void main(String[] args) {
        int[] arr1={10,20,30,40,50};
        int[] arr2={8,12,15,17,90,100};
        
        int n1=arr1.length;
        int n2=arr2.length;
        int[] ans = new int[n1+n2];
        int i=0;// for index 1
        int j=0;
        int index=0;
        while(index<n1+n2){

            if(i==n1){
                ans[index++] = arr2[j];
                j++;
                //index++;
                
                continue;// then it will go to while loop.
            }
            if(j==n2){
                ans[index++] = arr1[i];
                i++;
                //index++;
                continue;// then it start the while loop
            }
            
            if(arr1[i]<=arr2[j]){
                ans[index] =arr1[i];
                i++;
                System.out.println("if |->"+ans[index]);
                index++;
            }else{
                ans[index] = arr2[j];
                j++;
                System.out.println("else |->"+ans[index]);
                index++;
            }
        }
        System.out.println(" working");
        for(int k=0; k<ans.length;k++){
            System.out.println(ans[k]);
        }
    }
}
output is 
else |->8
if |->10
else |->12
else |->15
else |->17
if |->20
if |->30
if |->40
if |->50
 working
8
10
12
15
17
20
30
40
50
90
100. 


// Merge Sort
class Main {
    public static void merge(int[] arr,int low1,int high1, int low2, int high2){
        int [] result = new int[(high2- low1+1)];
        int resultindex = 0;
        int index1 = low1;
        int index2 = low2;
        while(resultindex < result.length){
            if(index1>high1){// if 
                result[resultindex]=arr[index2];
                index2++;
                resultindex++;
                continue;
            }
            if(index2> high2){
                result[resultindex]=arr[index1];
                index1++;
                resultindex++;
                continue;
            }
            if(arr[index1]<arr[index2]){
                result[resultindex]=arr[index1];
                resultindex++;
                index1++;
            }else{
                result[resultindex]=arr[index2];
                resultindex++;
                index2++;
            }
            
        }
        for(int i=0;i<result.length;i++){
            arr[low1++] = result[i];
        }
    }
    public static void mergeSort(int[] arr,int low,int high){
        if(low >=high) return;// because return type is void
        int mid = (low+high)/2;
        mergeSort(arr,low,mid);
        mergeSort(arr, mid+1,high);
        merge(arr, low, mid, mid+1, high);
    }
    public static void main(String[] args) {
        int[] arr ={4,5,1,3,2};
        mergeSort(arr,0,arr.length-1);
        
        for(int i=0;i<arr.length;i++){
            System.out.println(arr[i]);
        }
        
        System.out.println("Try programiz.pro");
    }
}
output:
1
2
3
4
5
Try programiz.pro

