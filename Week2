Date: 3/3/2025..   Monday.
LeetCode 287. Find the Duplicate Number
Attempted

Medium

Topics

Companies
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and using only constant extra space.
 
Example 1:
Input: nums = [1,3,4,2,2]
Output: 2
Example 2:
Input: nums = [3,1,3,4,2]
Output: 3
Example 3:
Input: nums = [3,3,3,3,3]
Output: 3
 
Code 1 : brute force not work in leetcode because time limit exceeded
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length;
        for(int i =0;i< n-1;i++){
            for(int j=i+1;j<n;j++){
                if(nums[i]== nums[j]){
                    return nums[i];
                }
            }
        }
        return 0;
    }
}
Code 2: Using HashSet
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length;
       HashSet<Integer> hs=new HashSet <>();
       for(int i =0;i<n;i++){
        int num = nums[i];
        if(!hs.contains(num)){
            hs.add(num);
        }
        else if(hs.contains(num)){
            return num;
        }
       }
        return 0;
    }
}
Code 3: Using HashMap
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length;
       HashMap<Integer,Integer> hs=new HashMap <>();
       for(int i =0;i<n;i++){
        int num = nums[i];
        if(!hs.containsKey(num)){
            hs.put(num,1);
        }
        else if(hs.containsKey(num)){
            return num;
        }
       }
        return 0;
    }
}

Code 4: Brute force Running in Leetcode

242. Valid Anagram
Solved

Easy

Topics

Companies
Given two strings s and t, return true if t is an anagram of s, and false otherwise.
 
Example 1:
Input: s = "anagram", t = "nagaram"
Output: true
Example 2:
Input: s = "rat", t = "car"
Output: false
Code 2: using two frequency arrays
class Solution {
    public boolean isAnagram(String s, String t) {
        boolean ans = true;
        int[] sfreq = new int[26];
        int[] rfreq = new int[26];
        for(int i=0;i<s.length();i++){
            char sc = s.charAt(i);
            int sindex = sc-'a';
            sfreq[sindex]++;
        }
        for(int i =0;i<t.length();i++){
            char rc = t.charAt(i);
            int rindex = rc-'a';
            rfreq[rindex]++;
        }
        for(int i=0;i<sfreq.length;i++){
            if(sfreq[i]!=rfreq[i]){
                ans = false;
            }
        }
        return ans;
    }
}

String Duplicates Removal

https://www.geeksforgeeks.org/problems/remove-all-duplicates-from-a-given-string4321/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card

Difficulty: EasyAccuracy: 58.68%Submissions: 105K+Points: 2Average Time: 15m

Given a string s which may contain lowercase and uppercase characters. The task is to remove all duplicate characters from the string and find the resultant string. The order of remaining characters in the output should be same as in the original string.
Example 1:
Input: s = "geEksforGEeks" Output: "geEksforG" Explanation: After removing duplicate characters such as E, e, k, s, we have string as "geEksforG".
Code 1: using hashes and StringBuilder
class Solution {
    String removeDuplicates(String s) {
        HashSet <Character> hs = new HashSet<>();
        StringBuilder ans = new StringBuilder(); 
        for(int i=0; i<s.length();i++){
            char c = s.charAt(i);
            if(!hs.contains(c)){
                hs.add(c);
                ans.append(c);
            }
            
        }
        String result= ans.toString();
        return result;   
    }
}
Code 2: using frequency array method

class Solution {
    String removeDups(String s) {
        // code here
        int[] freq =new int[256];
        StringBuilder ans = new StringBuilder(); 
        for(int i=0; i<s.length();i++){
            char c = s.charAt(i);
            int index = (int) c;
            freq[index]++;
            if(freq[index]==1){
                ans.append(c);
            }
            
        }
        // String result= ans.toString();
        // return result;
        return ans.toString();
    }
}
// code to remove non alphanumeric vaules from string and converting the string to all lower case.
class Main {
    public static void main(String[] args) {
        String s = "AB!Cba";
        s = s.replaceAll(
          "[^a-zA-z]", "");
        s=s.toLowerCase();
        
        for(int i=0;i<s.length();i++){
            System.out.println(s.charAt(i));
        }
    }
}
LeetCode 125. Valid Palindrome
Easy

Topics

Companies
A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
Given a string s, return true if it is a palindrome, or false otherwise.
 
Example 1:
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
Code 1:
class Solution {
    public boolean isPalindrome(String s) {
        boolean ans = true;
        s=s.toLowerCase();
        s = s.replaceAll(
          "[^a-z0-9]”, "");
          int n = s.length();
          int i=0;
          int j=n-1;
          while(i<j){
            if(s.charAt(i)!= s.charAt(j)){
                ans =false;
            }
            i++;
            j--;
          }
        return ans;
    }
}
LeetCode 387. First Unique Character in a String
Solved

Easy

Topics

Companies
Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.
 
Example 1:
Input: s = "leetcode"
Output: 0
Explanation:
The character 'l' at index 0 is the first character that does not occur at any other index.
Example 2:
Input: s = "loveleetcode"
Output: 2

Code1: Using HashMap
class Solution {
    public int firstUniqChar(String s) {
        HashMap <Character,Integer> hs =new HashMap<>();
        for(int i =0; i<s.length();i++){
            char a =s.charAt(i);
            hs.put(a,hs.getOrDefault(a,0)+1);
        }
        for(int i =0;i<s.length();i++){
            if(hs.get(s.charAt(i))==1){
                return i;
            }
        }
        return -1;
    }
}

LeetCode 3. Longest Substring Without Repeating Characters
Solved

Medium

Topics

Companies

Hint
Given a string s, find the length of the longest substring without duplicate characters.
 
Example 1:
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Example 2:
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        int maxLength = 0;
        int l = 0;
        int r = 0;
        HashSet<Character> hs = new HashSet<>();

        while (r < s.length()) {
            if (!hs.contains(s.charAt(r))) {
                hs.add(s.charAt(r));
                maxLength = Math.max(maxLength, r - l + 1);
                r++;
            } else {
                hs.remove(s.charAt(l));
                l++;
            }
        }

        return maxLength;
    }
}
