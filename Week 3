Date: 10/3/2025 (Monday)

Count Inversions
Input: arr[] = [2, 4, 1, 3, 5]
Output: 3
Explanation: The sequence 2, 4, 1, 3, 5 has three inversions (2, 1), (4, 1), (4, 3).

class Solution {
    // Function to count inversions in the array.
    static int inversionCount(int arr[]) {
        return mergeSort(arr, 0, arr.length - 1);
    }
    public static int mergeSort(int arr[], int low, int high){
        int count = 0;
        if(low < high){
            int mid = (low  + high)/2;
           count += mergeSort(arr, low, mid);
           count += mergeSort(arr, mid + 1, high);
           count += merge(arr, low, mid, high);
        }
        return count;
    }
    public static int merge(int arr[], int l, int mid, int h){
        ArrayList<Integer> list = new ArrayList<>();
        int low = l;
        int high = mid + 1;
        int count = 0;
        while(low <= mid && high <= h){
            if(arr[low] <= arr[high]){
                list.add(arr[low]);
                low++;
            }else{
                count += (mid - low + 1);
                list.add(arr[high]);
                high++;
            }
        }
        while(low <= mid){
            list.add(arr[low]);
            low++;
        }
        while(high <= h){
            list.add(arr[high]);
            high++;
        }
        for(int i = l; i<= h; i++){
            arr[i] = list.get(i - l);
        }
        return count;
    }
}

Leetcode 33. Search in Rotated Sorted Array
Solved
Medium
Topics
Companies
There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

 

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

//Binary search
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = (left + right) / 2;

            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] >= nums[left]) {
                if (nums[left] <= target && target <= nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (nums[mid] <= target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }

        return -1;        
    }
}
Leetcode 162. Find Peak Element
Solved
Medium
Topics
Companies
A peak element is an element that is strictly greater than its neighbors.

Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -âˆž. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in O(log n) time.

 

Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
//Binary search approach
class Solution {
    public int findPeakElement(int[] nums) {
         int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] > nums[mid + 1]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return left; 
    }
}
