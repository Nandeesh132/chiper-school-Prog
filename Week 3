Date: 10/3/2025 (Monday)

Count Inversions
Input: arr[] = [2, 4, 1, 3, 5]
Output: 3
Explanation: The sequence 2, 4, 1, 3, 5 has three inversions (2, 1), (4, 1), (4, 3).

class Solution {
    // Function to count inversions in the array.
    static int inversionCount(int arr[]) {
        return mergeSort(arr, 0, arr.length - 1);
    }
    public static int mergeSort(int arr[], int low, int high){
        int count = 0;
        if(low < high){
            int mid = (low  + high)/2;
           count += mergeSort(arr, low, mid);
           count += mergeSort(arr, mid + 1, high);
           count += merge(arr, low, mid, high);
        }
        return count;
    }
    public static int merge(int arr[], int l, int mid, int h){
        ArrayList<Integer> list = new ArrayList<>();
        int low = l;
        int high = mid + 1;
        int count = 0;
        while(low <= mid && high <= h){
            if(arr[low] <= arr[high]){
                list.add(arr[low]);
                low++;
            }else{
                count += (mid - low + 1);
                list.add(arr[high]);
                high++;
            }
        }
        while(low <= mid){
            list.add(arr[low]);
            low++;
        }
        while(high <= h){
            list.add(arr[high]);
            high++;
        }
        for(int i = l; i<= h; i++){
            arr[i] = list.get(i - l);
        }
        return count;
    }
}

Leetcode 33. Search in Rotated Sorted Array
Solved
Medium
Topics
Companies
There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

 

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

//Binary search
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = (left + right) / 2;

            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] >= nums[left]) {
                if (nums[left] <= target && target <= nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (nums[mid] <= target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }

        return -1;        
    }
}
Leetcode 162. Find Peak Element
Solved
Medium
Topics
Companies
A peak element is an element that is strictly greater than its neighbors.

Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -âˆž. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in O(log n) time.

 

Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
//Binary search approach
class Solution {
    public int findPeakElement(int[] nums) {
         int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] > nums[mid + 1]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return left; 
    }
}

//////////////////////////////////////////////////////////////
Date: 11/03/2025

1358. Number of Substrings Containing All Three Characters
Solved
Medium
Topics
Companies
Hint
Given a string s consisting only of characters a, b and c.

Return the number of substrings containing at least one occurrence of all these characters a, b and c.

 

Example 1:

Input: s = "abcabc"
Output: 10
Explanation: The substrings containing at least one occurrence of the characters a, b and c are "abc", "abca", "abcab", "abcabc", "bca", "bcab", "bcabc", "cab", "cabc" and "abc" (again). 
code 1: Array Frequency approach
class Solution {
    public int numberOfSubstrings(String s) {
        int n = s.length();
        int cnt = 0;
        int[] arr = new int[3];

        int i = 0, j = 0;

        while (j < n) { 
            arr[s.charAt(j) - 'a']++; // Expand window by including `s[j]`
            
            // Shrink window when all three characters are present
            while (arr[0] > 0 && arr[1] > 0 && arr[2] > 0) {
                cnt += n - j;  // Count all valid substrings from i to end
                arr[s.charAt(i) - 'a']--; // Shrink window from `i`
                i++; // Move `i` forward
            }

            j++; // Expand `j`
        }

        return cnt;
    }
}

code2: using hashmap and two pointers

class Solution {
    public int numberOfSubstrings(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        int n = s.length();
        int count = 0;
        int i = 0, j = 0;

        while (j < n) {
            // Expand the window by including s[j]
            map.put(s.charAt(j), map.getOrDefault(s.charAt(j), 0) + 1);

            // Check if all three characters are present
            while (map.size() == 3) {
                count += n - j; // Count all valid substrings from i to end
                map.put(s.charAt(i), map.get(s.charAt(i)) - 1);

                // Remove character if its count becomes zero
                if (map.get(s.charAt(i)) == 0) {
                    map.remove(s.charAt(i));
                }

                i++; // Shrink window from the left
            }

            j++; // Expand window from the right
        }

        return count;
    }
}
//leetcode 49. Group Anagrams
Solved
Medium
Topics
Companies
Given an array of strings strs, group the anagrams together. You can return the answer in any order.

 

Example 1:

Input: strs = ["eat","tea","tan","ate","nat","bat"]

Output: [["bat"],["nat","tan"],["ate","eat","tea"]]

Explanation:

There is no string in strs that can be rearranged to form "bat".
The strings "nat" and "tan" are anagrams as they can be rearranged to form each other.
The strings "ate", "eat", and "tea" are anagrams as they can be rearranged to form each other.

code 
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        
        for (String word : strs) {
            char[] chars = word.toCharArray();
            Arrays.sort(chars);
            String sortedWord = new String(chars);
            
            if (!map.containsKey(sortedWord)) {
                map.put(sortedWord, new ArrayList<>());
            }
            
            map.get(sortedWord).add(word);
        }
        
        return new ArrayList<>(map.values());
    }
}

2126. Destroying Asteroids
Solved
Medium
Topics
Companies
Hint
You are given an integer mass, which represents the original mass of a planet. You are further given an integer array asteroids, where asteroids[i] is the mass of the ith asteroid.

You can arrange for the planet to collide with the asteroids in any arbitrary order. If the mass of the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass of the asteroid. Otherwise, the planet is destroyed.

Return true if all asteroids can be destroyed. Otherwise, return false.

 

Example 1:

Input: mass = 10, asteroids = [3,9,19,5,21]
Output: true
Explanation: One way to order the asteroids is [9,19,5,3,21]:
- The planet collides with the asteroid with a mass of 9. New planet mass: 10 + 9 = 19
- The planet collides with the asteroid with a mass of 19. New planet mass: 19 + 19 = 38
- The planet collides with the asteroid with a mass of 5. New planet mass: 38 + 5 = 43
- The planet collides with the asteroid with a mass of 3. New planet mass: 43 + 3 = 46
- The planet collides with the asteroid with a mass of 21. New planet mass: 46 + 21 = 67
All asteroids are destroyed.
Example 2:

Input: mass = 5, asteroids = [4,9,23,4]
Output: false
Explanation: 
The planet cannot ever gain enough mass to destroy the asteroid with a mass of 23.
After the planet destroys the other asteroids, it will have a mass of 5 + 4 + 9 + 4 = 22.
This is less than 23, so a collision would not destroy the last asteroid.


class Solution {
    public boolean asteroidsDestroyed(int mass, int[] asteroids) {
        Arrays.sort(asteroids);
        long m = mass;
        int len = asteroids.length;
        for (int i = 0; i < len; i++) {
            if (m >= asteroids[i]) {
                m += asteroids[i];
            } else {
                return false;
            }
        }
        return true;
    }
}
